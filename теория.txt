1. Стек, статическая память и сегмент кода
Сегмент кода (.text)

Что хранится: Исполняемый код программы, функции, константы времени компиляции

Характеристики: Только для чтения, размер фиксирован при компиляции

Статическая память

Сегмент .data: Инициализированные глобальные и статические переменные

c
int global_var = 42;        // хранится в .data
static int static_var = 100; // хранится в .data
Сегмент .bss: Неинициализированные глобальные и статические переменные

c
int global_uninit;          // хранится в .bss
static int static_uninit;   // хранится в .bss
Стек (Stack)

Что хранится: Локальные переменные, параметры функций, адреса возврата

Управление: Автоматическое (компилятором)

Особенности: Быстрый доступ, LIFO (Last-In-First-Out)

c
void function() {
    int local_var = 10;     // хранится на стеке
    char buffer[100];       // хранится на стеке
}
2. Динамическая память (Куча/Heap)
Куча - это область памяти для динамического выделения в runtime.

Отличия от стека:

Стек	Куча
Автоматическое управление	Ручное управление
Ограниченный размер	Большой размер
Быстрый доступ	Медленнее
LIFO	Произвольный доступ
Локальные переменные	Динамические объекты
Почему нужно ручное управление:

c++
void function() {
    int* ptr = new int[1000]; // выделили в куче
    // используем массив...
    // забыли delete[] ptr -> УТЕЧКА ПАМЯТИ!
} // локальная переменная ptr уничтожается, но память в куче остается
3. Организация памяти и указатели
Память компьютера - линейная последовательность байтов, каждый имеет уникальный адрес.

Указатели - переменные, хранящие адреса памяти:

c++
int x = 10;
int* ptr = &x; // ptr хранит адрес переменной x
4. Операции с указателями
c++
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

// Разыменование
cout << *ptr; // 1

// Получение адреса
cout << &arr[0]; // адрес первого элемента

// Арифметика указателей
ptr++;       // теперь указывает на arr[1]
ptr = ptr + 2; // теперь указывает на arr[3]
int diff = ptr - arr; // diff = 3 (количество элементов между указателями)

// Сравнение
if (ptr1 == ptr2) // сравниваем адреса
if (ptr1 < ptr2)  // какой адрес меньше
5. Операторы new и delete
new - выделяет память в куче и вызывает конструктор
delete - вызывает деструктор и освобождает память

Почему медленнее стека:

Системные вызовы к менеджеру памяти ОС

Поиск подходящего блока памяти

Синхронизация в многопоточных программах

Возможная фрагментация памяти

c++
// Медленнее чем int x; на стеке
int* ptr = new int; 
delete ptr;
6. Утечка памяти (Memory Leak)
Memory Leak - ситуация, когда память выделена, но не освобождена.

Пример:

c++
void leak() {
    while(true) {
        int* data = new int[1000]; // утечка на каждой итерации
        // забыли delete[] data
    }
}
Проблемы:

Программа потребляет все больше памяти

Замедление работы системы

Аварийное завершение при нехватке памяти

7. Undefined Behavior и Double Free
Undefined Behavior (UB) - поведение программы, не определенное стандартом:

c++
int* ptr = new int;
delete ptr;
*ptr = 10; // UB - использование после удаления
Double Free - повторное освобождение памяти:

c++
int* ptr = new int;
delete ptr;
delete ptr; // ОШИБКА: double free
Проблемы: Повреждение кучи, краш программы, уязвимости безопасности.

8. AddressSanitizer
Компиляция с ASan:

bash
g++ -fsanitize=address -g program.cpp -o program
clang++ -fsanitize=address -g program.cpp -o program
Флаги:

-fsanitize=address - включить AddressSanitizer

-g - добавить отладочную информацию

9. reinterpret_cast
reinterpret_cast - приведение, интерпретирующее битовое представление:

c++
int x = 42;
float* fptr = reinterpret_cast<float*>(&x);
Осторожность нужна потому что:

Обходит систему типов

Может нарушить выравнивание

Зависит от платформы

Легко получить UB

10. Константность указателей
const int ptr* - указатель на константные данные:

c++
const int* ptr = &x;
// *ptr = 10; // ОШИБКА: данные константные
ptr = &y;     // OK: указатель можно изменить
int const ptr* - константный указатель на данные:

c++
int* const ptr = &x;
*ptr = 10;    // OK: данные можно изменить
// ptr = &y;  // ОШИБКА: указатель константный
const int const ptr* - константный указатель на константные данные:

c++
const int* const ptr = &x;
// *ptr = 10; // ОШИБКА: данные константные
// ptr = &y;  // ОШИБКА: указатель константный
Правило чтения: читать справа налево:

const int* - указатель на const int

int* const - константный указатель на int